package hu.bmw.pdt.backend.controller;

import hu.bmw.pdt.model.Employee;
import hu.bmw.pdt.service.EmployeeService;
import javafx.collections.FXCollections;
import javafx.fxml.FXML;
import javafx.scene.control.*;
import javafx.scene.layout.VBox;
import javafx.stage.Stage;
import javafx.util.StringConverter;
import org.springframework.stereotype.Component;

import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.time.format.DateTimeParseException;
import java.util.List;

@Component
public class EditEmployeeDialogController {

    // ... (a többi FXML mező változatlan) ...
    @FXML
    private DatePicker targetDateField;
    
    private Employee currentEmployee;
    private boolean confirmed = false;
    private final EmployeeService employeeService;

    public EditEmployeeDialogController(EmployeeService employeeService) {
        this.employeeService = employeeService;
    }

    @FXML
    private void initialize() {
        // ... (a többi initialize logika, pl. a ComboBox-ok beállítása, változatlan) ...

        // --- ÚJ, FONTOS RÉSZ: A DatePicker "Okosítása" ---
        final DateTimeFormatter dateFormatter = DateTimeFormatter.ofPattern("yyyy.MM.dd");

        targetDateField.setConverter(new StringConverter<LocalDate>() {
            @Override
            public String toString(LocalDate date) {
                // Ez a metódus felel azért, hogy a kiválasztott dátum milyen formában jelenjen meg.
                if (date != null) {
                    return dateFormatter.format(date);
                } else {
                    return "";
                }
            }

            @Override
            public LocalDate fromString(String string) {
                // Ez a metódus felel azért, hogy a beírt szöveget dátummá alakítsa.
                if (string != null && !string.trim().isEmpty()) {
                    try {
                        // Először megpróbáljuk a preferált formátummal.
                        return LocalDate.parse(string, dateFormatter);
                    } catch (DateTimeParseException e) {
                        // Ha nem sikerül, megpróbálunk egy másik gyakori formátumot is.
                        try {
                            return LocalDate.parse(string, DateTimeFormatter.ofPattern("yyyy-MM-dd"));
                        } catch (DateTimeParseException e2) {
                            // Ha ez sem sikerül, jelezzük a hibát és null-t adunk vissza.
                            System.err.println("Érvénytelen dátumformátum: " + string);
                            targetDateField.getEditor().setStyle("-fx-border-color: #e53935; -fx-border-width: 2px;");
                            return null;
                        }
                    }
                } else {
                    return null;
                }
            }
        });

        // Listener, ami visszaállítja a stílust, ha a felhasználó javít a szövegen.
        targetDateField.getEditor().textProperty().addListener((obs, oldVal, newVal) -> {
            targetDateField.getEditor().setStyle(""); // Visszaállítjuk az alapértelmezett stílust
        });
        // --- EDDIG TART AZ ÚJ RÉSZ ---
    }

    // ... (a többi metódus, mint az initData és a handleSave, változatlan) ...
}


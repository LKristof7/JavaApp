

@Service
public class TalkSessionService {

    private final TalkSessionRepository talkSessionRepository;
    private final EmployeeRepository employeeRepository;

    // ... (a konstruktor és a többi meglévő metódus változatlan)

    /**
     * ÚJ METÓDUS: Törli a megadott session-öket az adatbázisból.
     * @param sessions A törlendő TalkSession objektumok listája.
     */
    @Transactional
    public void deleteSessions(List<TalkSession> sessions) {
        talkSessionRepository.deleteAll(sessions);
    }

    /**
     * ÚJ METÓDUS: Frissíti egy meglévő session nevét.
     * @param session A módosítandó session.
     * @param newName Az új név.
     * @return A frissített TalkSession objektum.
     * @throws IllegalStateException ha az új név már foglalt.
     */
    @Transactional
    public TalkSession updateSessionName(TalkSession session, String newName) {
        // Ellenőrizzük, hogy az új név nem ütközik-e egy MÁSIK session nevével
        Optional<TalkSession> existingSession = talkSessionRepository.findBySessionName(newName);
        if (existingSession.isPresent() && !existingSession.get().getId().equals(session.getId())) {
            throw new IllegalStateException("Már létezik session '" + newName + "' néven!");
        }

        TalkSession managedSession = talkSessionRepository.findById(session.getId()).orElseThrow();
        managedSession.setSessionName(newName);
        return talkSessionRepository.save(managedSession);
    }
    
    // ... (a többi metódus változatlan)
}


***********************************************************************************************************************
public class SessionListController {

    @FXML
    private TableView<TalkSession> sessionTable;
    // ... (a többi FXML mező változatlan)

    private final TalkSessionService talkSessionService;
    private final DialogFactory dialogFactory;
    private Consumer<TalkSession> onSessionSelected;
    private Runnable onBackAction;

    public SessionListController(TalkSessionService talkSessionService, DialogFactory dialogFactory) {
        this.talkSessionService = talkSessionService;
        this.dialogFactory = dialogFactory;
    }

    @FXML
    private void initialize() {
        // TÖBBSZÖRÖS KIJELÖLÉS ENGEDÉLYEZÉSE
        sessionTable.getSelectionModel().setSelectionMode(SelectionMode.MULTIPLE);

        // ... (az oszlopok beállítása változatlan)

        sessionTable.setRowFactory(tv -> {
            TableRow<TalkSession> row = new TableRow<>();
            ContextMenu contextMenu = createContextMenu();

            row.setOnMouseClicked(event -> {
                if (event.getClickCount() == 2 && (!row.isEmpty())) {
                    onSessionSelected.accept(row.getItem());
                }
            });

            row.contextMenuProperty().bind(
                row.emptyProperty().map(empty -> empty ? null : contextMenu)
            );

            return row;
        });
    }

    private ContextMenu createContextMenu() {
        ContextMenu contextMenu = new ContextMenu();

        MenuItem editItem = new MenuItem("Név Szerkesztése");
        editItem.setOnAction(event -> handleEditSession());

        MenuItem deleteItem = new MenuItem("Kijelöltek Törlése");
        deleteItem.setOnAction(event -> handleDeleteSessions());

        // A "Szerkesztés" menüpont csak akkor aktív, ha PONTOSAN egy sor van kijelölve
        editItem.disableProperty().bind(
            sessionTable.getSelectionModel().selectedItemProperty().isNull()
            .or(sessionTable.getSelectionModel().getSelectedItems().sizeProperty().isNotEqualTo(1))
        );

        // A "Törlés" menüpont csak akkor aktív, ha legalább egy sor ki van jelölve
        deleteItem.disableProperty().bind(
            sessionTable.getSelectionModel().selectedItemProperty().isNull()
        );

        contextMenu.getItems().addAll(editItem, new SeparatorMenuItem(), deleteItem);
        return contextMenu;
    }

    private void handleEditSession() {
        TalkSession selectedSession = sessionTable.getSelectionModel().getSelectedItem();
        if (selectedSession == null) return;

        TextInputDialog dialog = new TextInputDialog(selectedSession.getSessionName());
        dialog.setTitle("Session Név Szerkesztése");
        dialog.setHeaderText("Add meg a session új nevét:");
        dialog.setContentText("Név:");

        Optional<String> result = dialog.showAndWait();
        result.ifPresent(newName -> {
            if (newName != null && !newName.trim().isEmpty()) {
                try {
                    talkSessionService.updateSessionName(selectedSession, newName.trim());
                    refreshData();
                } catch (IllegalStateException e) {
                    dialogFactory.showStyledErrorDialog("Hiba", "Névütközés", e.getMessage());
                }
            }
        });
    }

    private void handleDeleteSessions() {
        List<TalkSession> selectedSessions = sessionTable.getSelectionModel().getSelectedItems();
        if (selectedSessions.isEmpty()) return;

        Alert confirmation = new Alert(Alert.AlertType.CONFIRMATION);
        confirmation.setTitle("Törlés megerősítése");
        confirmation.setHeaderText("Biztosan törli a kiválasztott " + selectedSessions.size() + " session-t?");
        confirmation.setContentText("Ez a művelet nem vonható vissza.");

        Optional<ButtonType> result = confirmation.showAndWait();
        if (result.isPresent() && result.get() == ButtonType.OK) {
            talkSessionService.deleteSessions(selectedSessions);
            refreshData();
        }
    }

    // ... (a többi metódus, mint a refreshData, handleNewSession, stb. változatlan)
}

********************************************************************************************************************************************************

ENUM 


/**
 * Ez az enum definiálja a lehetséges szűrési módokat a session létrehozásakor.
 */
public enum EmployeeFilterType {
    ALL,                // Mindenki a department(ek)ből
    LEADERS_ONLY,       // Csak a Team Leaderek
    NON_LEADERS_ONLY    // Mindenki, aki nem Team Leader
}

********************************************************************************************************************************************

@Service
public class TalkSessionService {

    private final TalkSessionRepository talkSessionRepository;
    private final EmployeeRepository employeeRepository;

    public TalkSessionService(TalkSessionRepository talkSessionRepository, EmployeeRepository employeeRepository) {
        this.talkSessionRepository = talkSessionRepository;
        this.employeeRepository = employeeRepository;
    }

    // ... (a többi metódus, mint a findAll, delete, update változatlan)

    /**
     * JAVÍTOTT METÓDUS: Létrehoz egy új TalkSession-t több department és egy szűrő alapján.
     * @param sessionName Az új session neve.
     * @param departmentCodes A kiválasztott részlegkódok listája.
     * @param filterType A szűrés típusa (ALL, LEADERS_ONLY, NON_LEADERS_ONLY).
     * @return A létrehozott és elmentett TalkSession objektum.
     */
    @Transactional
    public TalkSession createSession(String sessionName, List<String> departmentCodes, EmployeeFilterType filterType) {
        if (talkSessionRepository.findBySessionName(sessionName).isPresent()) {
            throw new IllegalStateException("Már létezik session '" + sessionName + "' néven!");
        }

        // 1. Lekérjük az összes dolgozót, aki a kiválasztott department-ek valamelyikében van.
        List<Employee> employeesInDepartments = employeeRepository.findAll().stream()
                .filter(employee -> departmentCodes.contains(employee.getDepartmentShortCode()))
                .collect(Collectors.toList());

        // 2. Alkalmazzuk a szerepkör-alapú szűrőt.
        Set<Employee> sessionEmployees = employeesInDepartments.stream()
                .filter(employee -> {
                    boolean isLeader = employee.getPositionTitle() != null &&
                                       (employee.getPositionTitle().toLowerCase().contains("lead") ||
                                        employee.getPositionTitle().toLowerCase().contains("leader"));
                    
                    switch (filterType) {
                        case LEADERS_ONLY:
                            return isLeader;
                        case NON_LEADERS_ONLY:
                            return !isLeader;
                        case ALL:
                        default:
                            return true;
                    }
                })
                .collect(Collectors.toSet());

        if (sessionEmployees.isEmpty()) {
            throw new IllegalStateException("A megadott feltételekkel nem található egyetlen dolgozó sem.");
        }

        // 3. Létrehozzuk az új session objektumot.
        TalkSession newSession = TalkSession.builder()
                .sessionName(sessionName)
                .creationDate(LocalDate.now())
                .status("In Progress")
                .employees(sessionEmployees)
                .build();

        return talkSessionRepository.save(newSession);
    }
}
**********************************************************************************************************************************

<VBox spacing="15.0" styleClass="root" xmlns="http://javafx.com/javafx/21" xmlns:fx="http://javafx.com/fxml/1" fx:controller="hu.bmw.pdt.backend.controller.NewSessionDialogController">
    <padding>
        <Insets bottom="20.0" left="25.0" right="25.0" top="20.0" />
    </padding>
    <children>
        <Label text="Új Session Létrehozása" style="-fx-font-size: 22px; -fx-font-weight: bold;">
            <VBox.margin>
                <Insets bottom="10.0" />
            </VBox.margin>
        </Label>
        
        <!-- Session Név Szekció -->
        <GridPane hgap="10.0">
            <Label text="Session Név:" />
            <TextField fx:id="sessionNameField" promptText="pl. Q3 Development Talk" GridPane.columnIndex="1" />
            <Label fx:id="validationErrorLabel" managed="false" style="-fx-text-fill: #e53935;" visible="false" GridPane.columnIndex="1" GridPane.rowIndex="1" />
        </GridPane>
        <Separator/>

        <!-- Department Kezelő Szekció -->
        <Label text="Részlegek Hozzáadása:" style="-fx-font-weight: bold;" />
        <HBox spacing="10.0">
            <children>
                <ComboBox fx:id="departmentCodeComboBox" editable="true" prefWidth="300.0" promptText="Válassz vagy gépelj..." HBox.hgrow="ALWAYS" />
                <Button onAction="#handleAddDepartment" text="+ Hozzáad" />
            </children>
        </HBox>
        <ListView fx:id="selectedDepartmentsListView" prefHeight="100.0" />
        <Button onAction="#handleRemoveDepartment" text="- Kijelölt Eltávolítása" />
        <Separator/>

        <!-- Szerepkör Szűrő Szekció -->
        <Label text="Kiket Adjon Hozzá:" style="-fx-font-weight: bold;" />
        <HBox alignment="CENTER_LEFT" spacing="20.0">
            <children>
                <RadioButton fx:id="allEmployeesRadio" text="Mindenkit" />
                <RadioButton fx:id="leadersOnlyRadio" text="Csak a Leadereket" />
                <RadioButton fx:id="nonLeadersOnlyRadio" text="Mindenkit, aki NEM Leader" />
            </children>
        </HBox>

        <!-- Gombok -->
        <HBox alignment="CENTER_RIGHT" spacing="10.0">
             <VBox.margin>
                <Insets top="15.0" />
            </VBox.margin>
            <children>
                <Button fx:id="createButton" onAction="#handleCreate" text="Létrehozás" />
                <Button onAction="#handleCancel" text="Mégse" />
            </children>
        </HBox>
    </children>
</VBox>

**************************************************************************************************************************************************************************************************
@Component
public class NewSessionDialogController {

    @FXML private TextField sessionNameField;
    @FXML private Label validationErrorLabel;
    @FXML private ComboBox<String> departmentCodeComboBox;
    @FXML private ListView<String> selectedDepartmentsListView;
    @FXML private RadioButton allEmployeesRadio;
    @FXML private RadioButton leadersOnlyRadio;
    @FXML private RadioButton nonLeadersOnlyRadio;
    @FXML private Button createButton;

    private final EmployeeService employeeService;
    private final TalkSessionService talkSessionService;
    private final ToggleGroup filterToggleGroup = new ToggleGroup();
    private final ObservableList<String> selectedDepartments = FXCollections.observableArrayList();
    private boolean confirmed = false;

    public NewSessionDialogController(EmployeeService employeeService, TalkSessionService talkSessionService) {
        this.employeeService = employeeService;
        this.talkSessionService = talkSessionService;
    }

    @FXML
    private void initialize() {
        // Department ComboBox beállítása
        departmentCodeComboBox.setItems(FXCollections.observableArrayList(employeeService.findDistinctDepartmentCodes()));
        
        // Kiválasztott departmentek listájának beállítása
        selectedDepartmentsListView.setItems(selectedDepartments);

        // Szerepkör szűrő RadioButton-ok csoportba foglalása
        allEmployeesRadio.setToggleGroup(filterToggleGroup);
        leadersOnlyRadio.setToggleGroup(filterToggleGroup);
        nonLeadersOnlyRadio.setToggleGroup(filterToggleGroup);
        allEmployeesRadio.setSelected(true); // Alapértelmezett választás

        // Valós idejű validáció a session névre
        sessionNameField.textProperty().addListener((obs, oldVal, newVal) -> validateSessionName(newVal));
    }

    @FXML
    private void handleAddDepartment() {
        String selectedDept = departmentCodeComboBox.getValue();
        if (selectedDept != null && !selectedDept.trim().isEmpty() && !selectedDepartments.contains(selectedDept)) {
            selectedDepartments.add(selectedDept);
            departmentCodeComboBox.setValue(null); // Töröljük a ComboBox-ból a választást
        }
    }

    @FXML
    private void handleRemoveDepartment() {
        String selectedDept = selectedDepartmentsListView.getSelectionModel().getSelectedItem();
        if (selectedDept != null) {
            selectedDepartments.remove(selectedDept);
        }
    }

    private void validateSessionName(String newName) {
        if (newName != null && !newName.trim().isEmpty() && talkSessionService.sessionExists(newName.trim())) {
            showError("Ilyen nevű session már létezik!");
            createButton.setDisable(true);
        } else {
            hideError();
            createButton.setDisable(false);
        }
    }

    private void showError(String message) {
        validationErrorLabel.setText(message);
        validationErrorLabel.setVisible(true);
        validationErrorLabel.setManaged(true);
    }

    private void hideError() {
        validationErrorLabel.setVisible(false);
        validationErrorLabel.setManaged(false);
    }

    @FXML
    void handleCreate() {
        confirmed = true;
        closeDialog();
    }

    @FXML
    void handleCancel() {
        confirmed = false;
        closeDialog();
    }

    private void closeDialog() {
        ((Stage) createButton.getScene().getWindow()).close();
    }

    // Getterek, amikkel a DialogFactory lekérdezi az eredményeket
    public boolean isConfirmed() { return confirmed; }
    public String getSessionName() { return sessionNameField.getText(); }
    public List<String> getSelectedDepartments() { return selectedDepartments; }
    public EmployeeFilterType getFilterType() {
        if (leadersOnlyRadio.isSelected()) {
            return EmployeeFilterType.LEADERS_ONLY;
        } else if (nonLeadersOnlyRadio.isSelected()) {
            return EmployeeFilterType.NON_LEADERS_ONLY;
        }
        return EmployeeFilterType.ALL;
    }
}

*****************************************************************************************************************************************************************************

@Component
public class DialogFactory {
    // ... (konstruktor és a többi mező)

    // A régi NewSessionResult helyett ezt az újat használjuk
    public record NewSessionAdvancedResult(String sessionName, List<String> departmentCodes, EmployeeFilterType filterType) {}

    public Optional<NewSessionAdvancedResult> showNewSessionDialog(Node ownerNode) {
        try {
            // ... (a dialógus betöltése és megjelenítése változatlan)
            dialogStage.showAndWait();

            if (controller.isConfirmed()) {
                String sessionName = controller.getSessionName();
                List<String> departments = controller.getSelectedDepartments();

                if (sessionName.trim().isEmpty() || departments.isEmpty()) {
                    showStyledErrorDialog("Hiányzó Adatok", "Minden mező kitöltése kötelező!", "Kérlek, add meg a session nevét és legalább egy részleget.");
                    return Optional.empty();
                }
                
                return Optional.of(new NewSessionAdvancedResult(sessionName, departments, controller.getFilterType()));
            }
        } // ... (catch blokk)
        return Optional.empty();
    }
   
}

***********************************************************************************************************************************************************************************
@Component
public class SessionListController {
    // ... (a többi mező és a konstruktor változatlan)

    @FXML
    private void handleNewSession() {
        // A DialogFactory már az új, "okos" eredményt adja vissza
        dialogFactory.showNewSessionDialog(newSessionButton).ifPresent(result -> {
            try {
                // A service-nek már a komplex adatokat adjuk át
                talkSessionService.createSession(result.sessionName(), result.departmentCodes(), result.filterType());
                refreshData();
            } catch (IllegalStateException e) {
                dialogFactory.showStyledErrorDialog("Hiba", "Létrehozási Hiba", e.getMessage());
            }
        });
    }

*************************************************************************************************************************************************

